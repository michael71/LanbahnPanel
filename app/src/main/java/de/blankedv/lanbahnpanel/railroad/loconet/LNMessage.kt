package de.blankedv.lanbahnpanel.railroad.loconet

import de.blankedv.lanbahnpanel.model.INVALID_INT
import java.lang.Integer.parseInt


/**
 *
 * @author mblank
 *
 * LNMessages are stored in their "String" (array) format like "A0", "02", "01", "5C"
 * which can be easily converted to an IntArray
 *
 * a textual intepretation of some LN Messages can be generated by calling the fun interpret()
 *
 * an ugly LACK message interpretation (ugly because some info from an older message is used)
 * is also implemented
 */
open class LNMessage {

    internal var msgXStr: Array<String> = arrayOf("00 00 00 00")
    // just as an example
    internal var len: Int = -1  // not valid

    /** remove unnecessary 'RECEIVE ' and convert to Array<String>*/
    constructor(m: String) {
        if (m.contains("RECEIVE ")) {
            val msg = m.substring(8)
            msgXStr = msg.split(" ").toTypedArray()
        } else {
            msgXStr = m.split(" ").toTypedArray()
        }
        len = msgXStr.size
    }

    /** make LNMessage-String from IntArray, add checksum */
    constructor(d: IntArray) {

        len = d.size + 1
        msgXStr = Array<String>(len, { "00" })
        var checksum = 0
        for (i in d.indices) {
            val dataByte = (d[i] and 0xff)
            checksum = checksum xor dataByte
            msgXStr[i] = String.format("%02X", dataByte);
        }
        msgXStr[len-1] = String.format("%02X", (checksum and 0xff))

    }

    companion object {
        var requestAddress = 0  // used for storing for awaiting LACK
        var requestTime = 0L    // used for storing for awaiting LACK
    }

    /** get a single byte like "B0" from LNMessage as Integer
     *  return -1 in case of error */
    private fun getInt(i: Int): Int {
        if (i <= len) {
            try {
                var value = parseInt(msgXStr[i], 16)
                return value
            } catch (e: NumberFormatException) {
                // do nothing
            }
        }

        return -1  // == INVALID
    }


    fun isLocoMessage(): Boolean {
        return ((msgXStr[0] == "A0") or
                (msgXStr[0] == "A1") or
                (msgXStr[0] == "A2"))
    }

    fun getOpCode(): String {
        if (len == -1) return "00"
        else return msgXStr[0]
    }

    fun getOpCode2(): String {
        if (len == -1) return "00"
        else return msgXStr[1]
    }

    fun toGlobalPower(): Int {
        if (msgXStr[0] == "82") return 0
        else if (msgXStr[0] == "83") return 1
        else return INVALID_INT
    }

    fun toAccessory(): Accessory {
        /* <0xB0>,<SW1>,<SW2>,<CHK> REQ SWITCH function
<SW1> =<0,A6,A5,A4- A3,A2,A1,A0>, 7 ls adr bits. A1,A0 select 1 of 4 input pairs in a DS54
<SW2> =<0,0,DIR,ON- A10,A9,A8,A7> Control bits and 4 MS adr bits.
,DIR=1 for Closed,/GREEN, =0 for Thrown/RED
,ON=1 for Output ON, =0 FOR output OFF */
        val adr = getSwitchAddress()
        val dir = getDirection()
        var state = 0
        if (getInt(2) and 0x10 !== 0) {  //ON/OFF
            state = 1
        }

        return Accessory(adr, dir, state)
    }

    fun saveSwitchRequest(): String {
        // example BC 4F 0F 03  => LACK B4 3C 50 27
        /* 0xBC ;REQ state of SWITCH
          ;<0xBC>,<SW1>,<SW2>,<CHK>  */
        requestAddress = getSwitchAddress()
        requestTime = System.currentTimeMillis()
        return "switch state req, a=" + requestAddress
    }

    fun evalLackToAccessory(): Accessory? {
        /* 0xB4 ;Long acknowledge
;<0xB4>,<LOPC>,<ACK1>,<CHK> Long acknowledge
;<LOPC> is COPY of OPCODE responding to (msb=0).
;LOPC=0 (unused OPC) is also VALID fail code
;<ACK1> is appropriate response code for the OPCode*/

        //check LOPC, must be 3C
        if (msgXStr[1] != "3C") return null

        // first check if we have a stored address and it is not "too old"
        val addr = requestAddress
        if ((requestAddress == 0) or
                ((System.currentTimeMillis() - requestTime) > 1000)) {
            return null;
        } else {
            requestAddress = 0  // reset
        }

        val dir1 = getInt(2) and 0x70   // is byte2 is 0x50 or 0x30
        if (dir1 == 0x50) {
            return Accessory(addr, 0, 0)
        } else {  // == 0x30
            return Accessory(addr, 1, 0)
        }
    }

    fun toSlotSpeed(): SlotSpeed {
        return SlotSpeed(getInt(1), getSpeed())
    }

    fun toSensor(): Sensor {
        // sensor message
        /* 0xB2 ; General SENSOR Input codes
        ; <0xB2>, <IN1>, <IN2>, <CHK>
         <IN1> =<0,A6,A5,A4- A3,A2,A1,A0>, 7 ls adr bits. A1,A0 select 1 of 4 inputs pairs in a DS54
         <IN2> =<0,X,I,L- A10,A9,A8,A7>   Report/status bits and 4 MS adr bits.
"I"=0 for DS54 "aux" inputs and 1 for "switch" inputs mapped to 4K SENSOR space.
(This is effectively a LEAST SIGNIFICANT Address bit when using DS54 input configuration)
"L"=0 for input SENSOR now 0V (LO) , 1 for Input sensor >=+6V (HI)
"X"=1, control bit , 0 is RESERVsED for future! */
        val adr = getSensorAddress()
        val state = getOnOffState()
        return Sensor(adr, state)
    }

    fun toLNCVString() : String {
        if (len < 6) return "?"

        return "UB Message src=$msgXStr[2] destL=$msgXStr[3] destH=$msgXStr[4]+ reqID=$msgXStr[5]"

    }

    private fun getSwitchAddress(): Int {
        if (len >= 4) {
            return 1 + (getInt(1) and 0x7f) + (getInt(2) and 0x0f) * 128
        } else {
            return 0
        }
    }

    private fun getSensorAddress(): Int {
        if (len >= 4) {
            val adr = 2 * ((getInt(1) and 0x7f) + (getInt(2) and 0x0f) * 128)
            var iBit = getInt(2) and 0x20
            if (iBit != 0) {
                iBit = 1
            }
            return adr + 1 + iBit
        } else {
            return 0
        }
    }

    private fun getDirection(): Int {
        var dir = getInt(2) and 0x20  // GREEN/RED
        if (dir != 0) {
            dir = 1
        }
        return dir
    }

    private fun getOnOffState(): Int {
        var state = 0
        if ((getInt(2) and 0x10) != 0) {  //ON/OFF
            state = 1
        }
        return state
    }

    private fun getSpeed(): Int {
        // speed is 0,1,2,3, ... 126
        //  but coded as 0x00, 0x02, 0x03, 0x04, ...0x7f
        var sp = getInt(2) - 1
        if (sp < 0) sp = 0
        return sp
    }


    fun updateOrCreateLissy(): Lissy? {
        /*  (m[2] & 0x03) + 0x01 = train category (1..4)
            (m[3] & 0x1F ) *128 + (m[4] & 0x7F) = lissy address (1 .. 4095)
            (m[5] * 128) + (m[6] & 0x7F) = loco address          */

        if (msgXStr[1] != ("08")) return null // no valid lissy message

        // there are different type of lissy messages, will be combined into one lissy object
        val lissyMsgType = getInt(3) and 0x60  // mask bits
        val lissyAdr = (getInt(3) and 0x1F) * 128 + (getInt(4) and 0x7F)
        val trainCat = (getInt(2) and 0x03) + 0x01
        var s = "lissy#" + lissyAdr

        when (lissyMsgType) {
            0x60 -> {
                // loco adr and direction message
                val loco = (getInt(5) and 0x7f) as Int * 128 + (getInt(6) and 0x7f)
                s += " loco# $loco cat=$trainCat dir S2->S1"
                return Lissy.update(lissyAdr, INVALID_INT, loco, trainCat, DIRECTION_BACKWARD)
                //update(lissyID: Int, sp: Int, adr: Int, c: Int, d: Int)
            }
            0x40 -> {
                // loco adr and direction message
                val loco = (getInt(5) and 0x7f) as Int * 128 + (getInt(6) and 0x7f) as Int
                s += " loco# $loco cat=$trainCat dir S1->S2"
                return Lissy.update(lissyAdr, INVALID_INT, loco, trainCat, DIRECTION_FORWARD)
            }
            0x00 -> {
                // loco adr message
                val loco = (getInt(5) and 0x7f) as Int * 128 + (getInt(6) and 0x7f) as Int
                s += " loco# $loco cat=$trainCat"
                return Lissy.update(lissyAdr, INVALID_INT, loco, trainCat, INVALID_INT)
            }
            0x20 -> {
                val lissySpeed = (getInt(5) and 0x7f) as Int * 128 + (getInt(6) and 0x7f) as Int
                s += " speed# $lissySpeed"
                return Lissy.update(lissyAdr, lissySpeed, INVALID_INT, INVALID_INT, INVALID_INT)
            }
            else -> return null
        }

    }

}


/** message length is already calculated by the LbServer, it can be derived from the OPCODE :
 * The OPCODES may be examined to determine message length and if subsequent response message is
required. Data bits D6 and D5 encode the message length. D3=1 implies Follow-on message/reply:
D7 D6 D5 D4 -- D3 D2 D1 D0
(Opcode Flag)
1 0 0 F        D C B A    Message is 2 bytes, including Checksum
1 0 1 F        D C B A    Message is 4 bytes, inc. checksum
1 1 0 F        D C B A    Message is 6 bytes, inc checksum
1 1 1 F        D C B A    Message in N bytes, where next byte in message is a 7 bit BYTE COUNT.
 */

// OPCodes not yet implemented:

/* "E7" -> if (msg.getS(1).equals("0E")) {
             if (requestSlotState === State.REQUEST) {
                 slotAquired = msg.getB(2)
                 val stat = Throttle.statusToString(msg.getB(3))
                 lblSlot.setText("slot=" + slotAquired
                         + " st=0x" + msg.getS(3)
                         + "(" + stat + ")")
                 btnStart.setEnabled(true)
                 if (stat != "In-Use") {
                     requestSlotState = State.NULLMOVE
                     lnc.send(Messages.nullMove(slotAquired))
                 } else {
                     disp.append(" stealing, aquire finished")
                     requestSlotState = State.HAVE_SLOT
                 }
             } else if (requestSlotState === State.NULLMOVE) {
                 disp.append(" aquire finished")
                 requestSlotState = State.HAVE_SLOT
             }
     } */

